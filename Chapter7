- Use of classical inheritance is always optional. Every problem that it solves can be solved another way.
- Mix-ins are groups of methods that are independent of class and can be mixed in to any object. (In Ruby - modules)
- Methods can be defined in a module and then the module can be added to any object. It's a perfect way to allow objects of different classes to play a common role using a single set of code.
- When an object includes a module, the methods defined therein become available via automatic delegation.
- The total set of messages to which an object can respond includes:
  - Those it implements
  - Those implemented in all objects above it in the hierarchy
  - Those implemented in any module that has been added to it
  - Those implemented in all modules added to any object above it in the hierarchy.
- Object should menage themselves, they should contain their own behavior. If your intrest is in object B, you should not be forced to know about object A if your only use of it is to find things out about B.
- If a medule sends a message it must provide an implementation, even if that implementation merely raises an error indicating that users of the module must implement the method.
- The search for the method goes that in that order:
  - Objects Singleton Class
  - Objects extened modules
  - Objects class
  - Objects class modules
  - Objects superclass
  - Objects superclass modules
  - Super class of objects superclas
  - And so on untill it reaches the top of the hierarchy.
- When a single class includes several different modules, the modules are placed in the method lookup path in reverse order of module inclusion. Thus, the methods of the last included module are encountered first in the lookup path.
- Including a module into a class adds the module's methods to the response set of all instances of that class.
- (Ruby) It is possible to add module's method to a single object, using extend keyword. Extending a class with a module creates class methods in that class, and extendind an instance of a class with a module creates instance methods in that instance.
- (Ruby) Any object can have ad hoc methods added directly to its own personal "Singleton class", which are unique to this specific object.
- Object that uses a variable with a name like type or category to determine what message to send to self contains two highly related but slightly different types. Code like this can be rearranged to use classical inheritance by putting the common code in an abstract superclass and creating subclasses for the different types.
- When a sending object checks the class of receiving object to determine what message to send, you have overlooked a duck type. In this situation all of the possible receiving objects play a common role, that should be codified as a duck type and receivers should implement the duck type's interface.
- In addition to sharing an interface, duck types might also share behavior. When they do, place the shared code in a module and include that module in each class or object that plays the role.
- Superclasses should not contain code that applies to same, but not all, subclasses.
- the code in a module also must apply to all who use it.
- When subclasses override a method to declare that they do not do that thing, thay come close to declaring that they are not that thing. Nothing good can come of this.
- If you cannot correctly identify the abstraction there may not be one, and if no common abstraction exists then inheritance is not the solution to your design problem.
- Subclasses must respond to every message in their superclasses interface, taking the same kinds of inputs and returning the same kinds of outputs. They are not permitted to do anything that forces others to check their type in order to know how to treat them or what to expect of them.
- Subtype should be substitute for its supertype, and in Ruby terms this means that an object should act like what it claims to be.
- Subclasses may accept input parameters that have broader restrictions and may return results that have narrower restrictions, all while remaining perfectly substitutable for their superclasses.
  Subclasses that fail to do that are declaring that they are not really a kind-of thier superclass and cast doubt on the correctness of the entire hierarchy.
- Liskov Substitution Principle (LSP). Let q(x) be a property provable about objeccts x of type T. Then q(y) should be true for objects y of type S where S is a subtype of T. In another words, subtypes must be substitutable for their supertypes.
- The fundamental coding technique for creating inheritable code is the template pattern. It allows you to separate abstract from the concrete. The abstract defines algorithm, and the concrete inheritors of the abstraction contribute specializations by overriding these template methods.
- The template methods represent the parts of the algorithm that vary and creating them forces you to make explicit decisions about what varies and what does not.
- Avoid writing code that requires its inheritors to send super if you can; instead use hook messages.
- The limitations of hook methods are just one of the many reasons to create shallow hierarchies.
- Deep hierarchies are bad.
